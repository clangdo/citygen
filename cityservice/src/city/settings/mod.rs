mod setting;
pub use setting::Setting as Setting;

mod tree;
use tree::TreeMap;

pub struct Settings {
    tree: TreeMap<Setting>,
}

#[derive(Debug)]
pub enum Error {
    NonexistantSetting,
}

impl Settings {
    pub fn new() -> Self {
        let mut tree = TreeMap::<Setting>::new();
        // Image parameters, these control properties of the image
        // returned by the service
        //
        // For now, just the size in pixels
        tree.add(["image", "width"], 2048);
        tree.add(["image", "height"], 2048);

        // City parameters, these control broad, overarching
        // properties of the city generated by the service
        //
        // For now, just the logical width/height in meters
        tree.add(["city", "width"], 1000.0);
        tree.add(["city", "height"], 1000.0);

        tree.add(["roads", "breadth"], 12.0);
        tree.add(["roads", "breadth", "distribution"], "normal");
        tree.add(["roads", "breadth", "min"], 15.0);
        tree.add(["roads", "breadth", "max"], 6.0);

        // The road generation parameters
        for dimension in ["x", "y"] {
            tree.add(["roads", "density", dimension], 1.0/100.0);
            tree.add(["roads", "density", dimension, "distribution"], "normal");
            tree.add(["roads", "density", dimension, "min"], 0.5/100.0);
            tree.add(["roads", "density", dimension, "max"], 2.0/100.0);

            tree.add(["buildings", "density", dimension], 4.0/100.0);
            tree.add(["buildings", "density", dimension, "distribution"], "normal");
            tree.add(["buildings", "density", dimension, "min"], 2.0/100.0);
            tree.add(["buildings", "density", dimension, "max"], 8.0/100.0);
        }

        Self { tree }
    }

    /// This function updates the settings tree with the values from
    /// the given cityscript. This function avoids overwriting
    /// keys with different types.
    ///
    /// Note that any mispellings result in an error.
    pub fn update(&mut self, cityscript: &str) -> Result<(), Error> {
        todo!();
    }

    pub fn get<'a, K>(&self, setting: K) -> Result<&Setting, Error> where
        K: IntoIterator<Item = &'a str>
    {
        self.tree.get(setting).ok_or(Error::NonexistantSetting)
    }

    pub fn unwrap_bool<'a, K>(&self, setting: K) -> bool where
        K: IntoIterator<Item = &'a str>
    {
        if let Setting::Bool(value) = self.get(setting).unwrap() {
            *value
        } else {
            panic!("Cannot find a boolean setting that should always be there. \
                    Please contact the developers.");
        }
    }
    
    pub fn unwrap_float<'a, K>(&self, setting: K) -> f64 where
        K: IntoIterator<Item = &'a str>
    {
        if let Setting::Float(value) = self.get(setting).unwrap() {
            *value
        } else {
            panic!("Cannot find a float setting that should always be there. \
                    Please contact the developers.");
        }
    }

    pub fn unwrap_string<'a, K>(&self, setting: K) -> String where
        K: IntoIterator<Item = &'a str>
    {
        if let Setting::String(value) = self.get(setting).unwrap() {
            value.clone()
        } else {
            panic!("Cannot find a string setting that should always be there. \
                    Please contact the developers.");
        }
    }
    
    fn set<'a, K>(&mut self, setting: K, to: Setting) -> Result<(), Error> where
        K: IntoIterator<Item = &'a str>,
    {
        self.tree.set(setting, to).map_err(|error| {
            match error {
                tree::Error::NonexistantKey => Error::NonexistantSetting,
            }})
    }
}
